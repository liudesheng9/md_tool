README-DEV
==========

This document explains how `md-tool` is organised and how to extend or maintain it. The CLI exposes Markdown utilities (split, combine, translate, etc.), a pipeline runner, and a Textual-based TUI. Everything lives under `md_tools/` with a thin compatibility launcher `split_markdown.py`.


## 1. Development Environment

- **Requirements**: Python 3.10+ (Textual and asyncio features rely on 3.10). Install build tooling with `python -m pip install -U pip setuptools wheel build`.
- **Editable install**: from the repo root run `python -m pip install -e .`. This wires the `md-tool` console entry point for local testing.
- **Running the CLI**: `md-tool <command>` (e.g. `md-tool split docs/note.md 3 -o docs/note_parts.md`). `python split_markdown.py ...` offers a no-install path.
- **TUI**: `md-tool tui <path-to-markdown-root>` launches the four-step Textual interface. Textual must be available in your environment.
- **Fake translation mode**: set `MD_TOOL_FAKE_TRANSLATE=stub` (or `reverse`, `identity`) to exercise translation without real requests; tests rely on this.
- **Packaging**: before releasing run `python -m build` to produce `dist/` artifacts.


## 2. Repository Layout

```
md_tools/
    cli.py                CLI entry point and sub-command registration.
    tools/                Tool registry + base class shared by all commands.
    split/, combine/, format_newlines/, translate/   Individual tool modules.
    pipeline/             Parser/executor plus stage-specific helpers.
    tool_manager/         JSON payload runner backing the TUI.
    tui/app.py            Textual-based multi-step UI.
    utils.py              Paragraph/newline helpers.
    manpage.py            `md-tool man` output.
split_markdown.py         Compatibility runner (`python split_markdown.py ...`).
test/                     Smoke tests, fixtures, and targeted unit tests.
```

Supporting artefacts (`build/`, `md_tools.egg-info/`) are generated by packaging and can be ignored during development.


## 3. Core CLI Architecture

### 3.1 Entry Point (`md_tools/cli.py`)

- `build_parser()` wires every registered `MDTool` (see below), the `translate` text command, the pipeline command (`PipelineCommand`), the TUI launcher, and the man page helper.
- `main()` parses CLI args and dispatches via the `func` attribute each tool sets.
- `_register_tui`/`_run_tui_command` launch the interactive builder; `_register_man`/`_run_man_command` print `md_tools/manpage.py`.

### 3.2 Tool Registry (`md_tools/tools`)

- `MDTool` (`md_tools/tools/base.py`) defines the contract for commands:
  - `configure_parser` registers CLI flags.
  - `run` executes the standalone command.
  - `run_pipeline` defaults to raising `PipelineStageError`; override when a stage implementation exists under `md_tools/pipeline/<tool>`.
  - `pipeline_caps` + `pipeline_output_spec` advertise pipeline behaviour (input multiplicity, intermediate outputs). These inform pipeline validation and the TUI.
- `ToolRegistry` (`md_tools/tools/__init__.py`) stores `ToolSpec` entries so CLI registration happens automatically once modules import and call `register_tool`.
- **Adding a tool**: create `md_tools/<tool_name>/__init__.py`, subclass `MDTool`, register it via `register_tool(tool, category=...)`, and add any pipeline helpers under `md_tools/pipeline/<tool_name>/`.


## 4. Built-in Tools

### 4.1 Split (`md_tools/split/__init__.py`)

- CLI arguments: `input`, `parts`/`--parts`, `-o/--output`.
- `split_paragraphs` uses paragraph lengths to balance content; `write_parts` emits numbered files `<stem>_part_<n>.md`.
- Pipeline stage (`md_tools/pipeline/split/__init__.py`):
  - Validates parts, loads upstream or stage input.
  - Reuses `split_paragraphs` then builds in-memory `MarkdownDocument`s or writes stage outputs (when `-o` provided).
  - `PipelineCaps`: consumes one doc, can emit many.
  - `_SplitOutputSpec` enumerates expected files when `-o` was passed so downstream checks and the TUI can surface them.

### 4.2 Combine (`md_tools/combine/__init__.py`)

- Accepts positional inputs or `--file-list`.
- `gather_inputs`, `validate_inputs`, `read_files`, `combine_contents` encapsulate I/O.
- Pipeline stage merges upstream documents with optional file inputs and can write its own `--output`.
- Caps: accepts multiple inputs (stage or upstream), produces single doc.

### 4.3 Format Newlines (`md_tools/format_newlines/__init__.py`)

- Expands single blank lines to double spacing unless they already belong to larger blank runs.
- Relies on the shared paragraph extractor metadata to distinguish intentional multi-line spacing from single blank separators.
- Pipeline stage optionally writes intermediate output; otherwise modifies the artifact in-place.

### 4.4 Translate Markdown (`md_tools/translate/translate_md.py`)

- Handles file translation paragraph by paragraph with concurrency, retry, delay, and cancellation controls.
- Major components:
  - `TranslateMarkdownTool.run` verifies inputs, orchestrates `translate_document`, writes final Markdown and optional debug JSON.
  - `ProgressPrinter` draws carriage-return based progress (consumed by CLI and TUI).
  - `MarkdownParagraphExtractor` (`md_tools/paragraphs.py`) parses Markdown into logical blocks (text, tables, HTML, equations, fences) while recording metadata for debugging; translation relies on this for accurate progress/debug data.
  - `StructureDetector` + `_segment_paragraph` ensure only natural-language segments are translated; code/tables/images are preserved.
  - `RequestDelayer` and `_translate_with_retry` manage pacing and retries, respecting `TranslationCancelToken`.
  - `translate_markdown_async` uses `ThreadPoolExecutor` to translate paragraphs concurrently and reports progress through a callback.
  - `_build_debug_records` + `_write_debug_output` output bilingual paragraph info.
- The simpler text command (`md_tools/translate/text.py`) exposes `md-tool translate`, `TranslationRequest`, the Google Translate HTTP client, and a fake mode for tests.
- Cancellation primitives live in `md_tools/translate/cancellation.py`.


## 5. Pipeline Subsystem (`md_tools/pipeline`)

- `core.py`
  - `PipelineDefinition` + `PipelineStage` describe parsed pipelines.
  - `_split_stages` tokenises the `=`-delimited CLI, `_parse_stage` reuses `build_parser()` to parse each stage in isolation, injecting `--parts` for `split` numeric shortcuts.
  - `build_pipeline_definition` enforces per-stage constraints (e.g., forbid positional input when `allow_stage_input` is false) and collects `pipeline_output_spec` paths.
  - `run_pipeline` streams a `MarkdownArtifact` through every stage, enforcing caps (`input_mode`, etc.) and wrapping raised exceptions as `PipelineStageError`.
- `command.py` exposes the `pipeline` CLI command, handles top-level `-i/--input`, optional global `-o`, and delegates to `build_pipeline_definition`/`run_pipeline`.
- `types.py` defines `MarkdownDocument`, `MarkdownArtifact`, and `PipelineStageError`.
- `stage_runner.py` is a helper used by stage packages to clone upstream artifacts, ensure single-document contracts, and write files with consistent error handling.
- Stage modules (`pipeline/split`, `/combine`, `/format_newlines`, `/translate_md`) wrap their respective tools for pipeline context, applying the same validations as standalone commands and writing stage outputs when flags are present.
- `PipelineOutputSpec` subclasses (one per tool) let both the pipeline executor and the TUI know which files should exist after a stage runs.


## 6. Tool Manager & Automation (`md_tools/tool_manager`)

- `ToolManager` builds pipeline definitions from JSON-friendly payloads (`PipelinePayload` + `StagePayload`) and executes them using the pipeline executor.
- `PipelinePayload.from_mapping` validates external input before execution.
- Used directly by the TUI and smoke tests (`test/smoke_tool_manager.py`) to run repeatable scenarios without parsing command strings manually.


## 7. Textual TUI (`md_tools/tui/app.py`)

`ToolManagerApp` (Textual `App`) drives a four-step wizard:

1. **StepOneScreen** – file selection. Uses `ListView` for Markdown files relative to the chosen root. Selection toggling now updates a single row (for performance) via `_update_item_marker`.
2. **StepTwoScreen** – pipeline builder. Lets users choose available tools (`app.tool_names`), append stages with arbitrary arguments (minus `-o/--output`, enforced by `_args_include_output`), visualise the current pipeline (`pipeline-graph`), and remove stages.
3. **StepThreeScreen** – output configuration. For each selected file and each stage flagged by `ToolManagerApp.stage_requires_output`, renders an `OutputField` that can be toggled off (non-final stages only). Defaults use `_default_output_path`. Changes feed `output_overrides`, `output_disabled`, etc., which `build_payloads` later consumes to insert `--output` flags via `apply_output_flag`.
4. **StepFourScreen** – execution log. Wraps `ToolManager.run_payloads` in `asyncio.to_thread` and captures stdout/stderr through `ScreenLogWriter`. The log parser keeps `\r`-driven progress (e.g., translate-md) on a single line while still recording newline-delimited output.

Key helpers inside `ToolManagerApp`:
- `ensure_output_defaults` computes per-file stage outputs and keeps disabled-stage state consistent when pipelines change.
- `build_payloads` translates UI state to `PipelinePayload` instances sent to `ToolManager`.
- `run_selected_pipelines` executes those payloads and surfaces a success message.

`OutputField` is a reusable widget (Label + optional toggle + Input) that posts `Changed`/`Toggled` messages consumed by StepThree.


## 8. Utilities & Supporting Files

- `md_tools/paragraphs.py`: shared paragraph detection utilities (`MarkdownParagraphExtractor`, `collect_paragraphs_with_metadata`).
- `md_tools/utils.py`: newline helpers (`detect_newline`, `normalise_paragraph_newlines`).
- `md_tools/manpage.py`: static manual text for `md-tool man`.
- `split_markdown.py`: legacy entry point calling `md_tools.cli.main`.
- `pipeline_structure.md`: high-level documentation of canonical stage orderings (reference only).


## 9. Testing & QA

- **Unit/feature tests**: run `python -m pytest -q`. Current coverage:
  - `test/test_tui_outputs.py` ensures the TUI’s output configuration logic behaves (disabled flags, final-stage enforcement).
- **Smoke tests** (`test/smoke_pipeline.py`):
  - Invokes `python split_markdown.py ...` to mimic installed behaviour.
  - Covers CLI/pipeline flows, stage output validation, translation fake mode, and file creation checks.
- **Tool manager smoke tests** (`test/smoke_tool_manager.py`):
  - Exercises `ToolManager` payload execution, stage output files, batch runs, and translation integration (again using fake mode).
- Always clean up generated files between runs (helpers already do this in tests). When adding new scenarios, keep fixtures under `test/`.
- For translation features, set `MD_TOOL_FAKE_TRANSLATE` so tests do not hit the network.


## 10. Common Maintenance Tasks

### 10.1 Adding a New Tool
1. Create `md_tools/<tool_name>/__init__.py`, subclass `MDTool`, implement `configure_parser`, `run`, and optionally `run_pipeline`.
2. Register via `register_tool(tool, category="...")`.
3. If pipeline support is needed, add `md_tools/pipeline/<tool_name>/__init__.py` and implement `run_stage` plus a `PipelineOutputSpec` if the stage writes files.
4. Update documentation (README, manpage) and add smoke tests under `test/`.
5. (Optional) surface the tool inside the TUI by ensuring the module imports during CLI startup (follow the existing `from . import module as _module` pattern in `cli.py`).

### 10.2 Extending the Pipeline
- Update `PipelineCaps` in your tool to describe input/output counts.
- Add extra validation in stage runners via `PipelineStageRunner`.
- Teach the TUI about new output flags by updating `OUTPUT_FLAG_MAP` (top of `md_tools/tui/app.py`) so StepThree renders the right inputs.

### 10.3 Modifying the TUI
- Keep Textual CSS in `APP_CSS` (top of `md_tools/tui/app.py`).
- Screens live in the same file for now; maintain the four-step flow and ensure new widgets post Textual events consumed by the relevant screen.
- When adjusting logging, retain the carriage-return behaviour inside `StepFourScreen.append_log`.

### 10.4 Translation Enhancements
- Modify `MarkdownParagraphExtractor` / `StructureDetector` when adding new Markdown constructs; update `_build_debug_records` to capture new metadata.
- Honour cancellation tokens in any async/worker additions to keep Ctrl+C responsive.
- If you introduce new CLI flags, also propagate defaults into the pipeline stage and the TUI (StepTwo should validate that forbidden flags are not embedded directly).


## 11. Release Checklist

1. Run `python -m pytest -q`.
2. Execute both smoke suites:
   - `python test/smoke_pipeline.py`
   - `python test/smoke_tool_manager.py`
3. Run the TUI manually against sample Markdown to ensure UX regressions are caught early (`md-tool tui test/`).
4. Update `README.md`, `README-DEV.md`, and `md_tools/manpage.py` if user-visible behaviour changed.
5. Build distributables with `python -m build`.

Following this document, a new contributor can understand where each feature lives, how commands register themselves, how pipelines are parsed/executed, and how to extend the TUI or translation stack without reverse-engineering the codebase.
